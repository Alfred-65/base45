<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE RFC SYSTEM "rfc2629.dtd" [
<!ENTITY RFC4648 SYSTEM
"http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC2119 SYSTEM
"http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>
<?xml-stylesheet type='text/xsl' href='RFC2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<!-- Expand crefs and put them inline -->
<?rfc comments='yes' ?>
<?rfc inline='yes' ?>  

<!-- afi
Comment 1: My editor claims "wrong root element, change root tag to RFC".
           Proposal: Check which root tag is correct.
           Obviously one of "rfc" or "RFC".
-->
<rfc docName="draft-faltstrom-base45-02" ipr="trust200902" category="std">
  <front>
    <title abbrev="Base45">
      The Base45 Data Encoding
    </title>
    <author fullname="Patrik Faltstrom" initials="P." surname="Faltstrom">
      <organization abbrev="Netnod">Netnod</organization>
      <address>
	<email>paf@netnod.se</email>
      </address>
    </author>
    <author fullname="Fredrik Ljunggren" initials="F." surname="Ljunggren">
      <organization abbrev="Kirei">Kirei</organization>
      <address>
	<email>fredrik@kirei.se</email>
      </address>
    </author>
    <author fullname="Dirk-Willem van Gulik" initials="D." surname="van Gulik">
      <organization abbrev="Webweaving">Webweaving</organization>
      <address>
	<email>dirkx@webweaving.org</email>
      </address>
    </author>
    <date month="March" year="2021" day="13"/>
    <area>Operations</area>
    <keyword>BASE45</keyword>
    <abstract>
      <t>
	This document describes the base 45 encoding scheme which is
	built upon the base 64, base 32 and base 16 encoding schemes.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" title="Introduction">
      <t>
	<!-- afi
	  Comment 1: The statement in the first sentence is not entirely true (if
	             taken literally). I tried to improve the statement.
	  Comment 2: I am not sure about Aztec. I might be possible that for Aztec
	             there are better encodings than base 45. Intentionally I
	             deleted the mentioning of Aztec.
	 -->
		  A QR-code is used to encode text as a graphical image. Depending on
		  the characters used in the text various encoding options for a QR-code
		  exists, e.g. numeric, alphanumeric and byte mode. Even in byte mode a
		  typical QR-code reader tires to interpret a byte sequence as an UTF-8
		  of ISo/IEC 8859-1 text. Thus QR-codes cannot be used to encode
		  arbitrary binary data directly. Such data has to be converted into
		  an appropriate text before that text could be encoded as a QR-code.
		  Compared to already established base 64, base 32 and base 16 encoding
		  schemes, that are described in <xref target="RFC4648">RFC 4648</xref>,
		  the base 45 scheme described in this document offer a more compact
		  QR-code encoding.
	  </t>
	  <t>
		  E.g. for base 64 arbitrary 12 byte are encoded into 16 characters. For
		  those characters the byte mode has to be used. This means with
		  base 64 arbitrary 12 bytes occupy 128 bit in an QR-code.
		  With base 45 those 12 byte are encoded into 18 character but the
		  alphanumeric mode could be used (where two characters are encoded into
		  11 bit). This means with base 45 arbitrary 12 byte occupy 99 bit in an
		  QR-code.
		  Compared to approximately 30% overhead with base 64 a base 45 approach
		  leads to only approximately 3% overhead.
      </t>
    </section>
    <section title="Conventions Used in This Document">
      <t>
	The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
	NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
	"OPTIONAL" in this document are to be interpreted as described
	in <xref target="RFC2119">RFC 2119</xref>.
      </t>
	  <t>
		  Strings are enclosed in quotation marks, e.g. "Foo Bar".
		  If not stated otherwise numbers are written with decimal digits.
		  Numbers with different radix are suffixed with "-bRadix". E.g.:
		  1001110101110101-b2 = 40309-b10 = 9d75-b16 = J+Y-b45.
	  </t>
    </section>
    <section title="Interpretation of Encoded Data">
      <t>
	Encoded data is to be interpreted as described in <xref
	target="RFC4648">RFC 4648</xref> with the exception that a
	different alphabet is selected.
      </t>
    </section>
    <section title="The Base 45 Encoding">
      <t>
	A 45-character subset of US-ASCII is used, the 45 characters
	that can be used in a QR-code in alphanumeric mode.
      </t>
      <t>
		  <!-- afi
		  Comment 1: In order to avoid misinterpretations with characters from
		             table 1, in the following I propose to use lower case
		             letters for a, b, c, d and e.
		  Comment 2: I propose a different wording here.
		  Observation 3: Bytes are processed in big-endian format, but the
		             resulting base 45 encoding is kind of little-endian.
		             From a programming point of view (especially when it
		             comes to decode a single byte) this is better than
		             big-endian, nice trick.
		  Comment 4: A single byte is ALWAYS encoded into 2 characters. In
		             case that single byte has an integer value less than 45
		             it would be possible to encode it into a single character.
		             This would save an additional character. In the end that
		             saved character might save 11 bits in the QR-code in case
		             the number of base 45 characters is odd.
		             When it comes to decoding then the rules would be:
		             a. Work an three characters at a time and extract two bytes.
		             b. If two character [c d] are left, then  a = c + 45*d.
		             c. If a single character [c] is left, then a = c.
		             The following text is such that rule c has to be:
		             c. If a single character is left, then ERROR in decoding.
		             Question: Is it possible to modify the specification
		             accordingly?
		  -->
		  For encoding two bytes [a b] SHALL be interpreted as a base 256 number,
		  i.e. as an unsigned integer over 16 bit. That integer SHALL be converted
		  to radix 45 [c d e] as follows: (a*256) + b = c + (45*(d + 45*e)).
		  Please note that the left-most byte [a] is the most significant byte,
		  but in base 45 intentionally the left-most character [c] is the least
		  significant.
		  The values c, d and e are then looked up in Table 1 to produce a
		  three character string.
      </t>
      <t>
		  For encoding a single byte [a] SHALL be interpreted as a base 256 number,
		  i.e. as an unsigned integer over 8 bit. That integer SHALL be converted
		  to radix 45 [c d] as follows: a = c + (45*d).
		  The values c and d are then looked up in Table 1 to produce a
		  two character string.
      </t>
	  <t>
		  A byte string [a b c d ... x y z] with arbitrary content and
		  arbitrary length SHALL be encoded as follows:
		  From left to right pairs of bytes are encoded as described above.
		  If the number of bytes is even, then the encoded form is a string
		  with a length which is divisible by 3.
		  If the number of byte is odd, then the last (rightmost) byte is
		  encoded on two characters as described above.
	  </t>
	  <t>
		  For decoding a base 45 encoded string the inverse operations are
		  performed.
	  </t>
      <t>
	<figure><artwork>
               Table 1: The Base 45 Alphabet

Value Encoding  Value Encoding  Value Encoding  Value Encoding
   00 0            12 C            24 O            36 Space
   01 1            13 D            25 P            37 $
   02 2            14 E            26 Q            38 %
   03 3            15 F            27 R            39 *
   04 4            16 G            28 S            40 +
   05 5            17 H            29 T            41 -
   06 6            18 I            30 U            42 .
   07 7            19 J            31 V            43 /
   08 8            20 K            32 W            44 :
   09 9            21 L            33 X
   10 A            22 M            34 Y
   11 B            23 N            35 Z
        </artwork></figure>
      </t>
      <section title="Encoding examples">
	<t>
	  Encoding example 1: The string "AB" as ASCII is the byte sequence [65
	  66]. The 16 bit value is 65 * 256 + 66 = 16706-b10. 16706-b10 equals
	  11 + 45 * 11 + 45 * 45 * 8 so the sequence in base 45 is [11
	  11 8]. By looking up these values in Table 1 we get the
	  encoded string "BB8".
	</t>
	<t>
	  Encoding example 2: The string "Hello!!" as ASCII is the byte
	  sequence [72 101 108 108 111 33 33]. If we look at each 16
	  bit value, it is [18533 27756 28449 33]. Note the 33 for the
	  last byte. When looking at the values modulo 45, we get [[38
	  6 9] [36 31 13] [9 2 14] [33 0]] where the last byte is
	  represented by two.  By looking up these values in Table 1
	  we get the encoded string "%69 VD92EX0".
	</t>
	<t>
	  Encoding example 3: The string "base-45" as ASCII is the byte
	  sequence [98 97 115 101 45 52 53]. If we look at each 16 bit
	  value, it is [25185 29541 11572 53]. Note the 53 for the
	  last byte. When looking at the values modulo 45, we get [[30
	  19 12] [21 26 14] [7 32 5] [8 1]] where the last byte is
	  represented by two.  By looking up these values in Table 1
	  we get the encoded string "UJCLQE7W581".
	</t>
      </section>
      <section title="Decoding examples">
	<t>
	  Decoding example 1: The string "QED8WEX0" represents when
	  lookup in Table 1 the values [26 14 13 8 32 14 33 0]. We
	  look at the numbers in three number sequences (except last)
	  and get [[26 14 13] [8 32 14] [33 0]].  In base 45 we get
	  [26981 29798 33] where the bytes are [[105 101] [116 102]
	  [33]].  If we look at the ascii values we get the string
	  "ietf!".
	</t>
      </section>
    </section>
    <section title="IANA Considerations">
      <t>
	There are no considerations for IANA in this document.
      </t>
    </section>
    <section title="Security Considerations">
      <t>
	When implementing encoding and decoding it is important to be
	very careful so that buffer overflow does not take place, or
	anything similar. This includes of course the calculations of
	modulo 45 and lookup in the table of characters. Decoder also
	must be robust regarding input, including proper handling of
	the NUL character (ASCII 0).
      </t>
      <t>
	Specifically it should be noted that Base 64 (for example) pad
	the string so that the encoding has the correct number of
	characters. This is something that base 45 does not do,
	i.e. base 45 do not include padding.  Because of this, special
	care is to be taken when odd number of octets are to be
	encoded which results not in N*3 characters, but (N-1)*3+2
	characters in the encoded string and vice versa, when the
	number of encoded characters are not divisible by 3.
      </t>
	  <t>
		  <!-- afi
		  Comment 1: Hereafter follows a copy from RFC 4648.
		  -->
		  Base encodings use a specific, reduced alphabet to encode binary
		  data. Non-alphabet characters could exist within base-encoded data,
		  caused by data corruption or by design. Non-alphabet characters may
		  be exploited as a "covert channel", where non-protocol data can be
		  sent for nefarious purposes. Non-alphabet characters might also be
		  sent in order to exploit implementation errors leading to, e.g.,
		  buffer overflow attacks.
	  </t>
	  <t>
		  Implementations SHALL reject the encoded data if it contains
		  characters outside the base alphabet when interpreting base-encoded
		  data, unless the specification referring to this document explicitly
		  states otherwise. Such specifications can instead state
		  that characters outside the base encoding alphabet should
		  simply be ignored when interpreting data ("be liberal in what you
		  accept").
	  </t>
	  <t>
		<!-- afi
		Comment 1: In my opinion it is worth mentioning the following:
		-->
		  Even though a base 45 encoded string contains only characters from
		  the alphabet in Table 1 the following case has to be considered:
		  The string "FGW" represents 65535-b10 = ffff-b16, which is a valid
		  encoding.
		  The string "GGW" would represent 65536-b10 = 10000-b16, which has more
		  than 16 bit.
		  Implementations SHALL reject the encoded data if it contains
		  a triplet of characters which, when decoded, result in an unsigned
		  integer which is greater then 65535-b10 = ffff-b16, unless the
		  specification referring to this document explicitly stated that
		  all decoded values SHALL be processed modulo 65536-b10. If so, then
		  e.g. both encodings "HGW" and "100" decode to integer 1 = 0001-b16.
	  </t>
    </section>
    <section title="Acknowledgements">
      <t>
	The authors thank Alan Barrett, Tomas Harreveld, Anders
	Lowinger and Jakob Schlyter for the feedback. Also everyone
	that have been working with Base64 during the years that have
	proven the implementions are stable.
      </t>
    </section>
  </middle>
  <back>
    <references title='Normative References'>
      &RFC4648;
      &RFC2119;
    </references>
  </back>
</rfc>
